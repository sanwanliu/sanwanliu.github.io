{"pages":[],"posts":[{"title":"18.验证二叉搜索树:leetcode-98 Search Tree","text":"problemGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees. Example 1: 123456 2 / \\ 1 3Input: [2,1,3]Output: true Example 2: 12345678 5 / \\ 1 4 / \\ 3 6Input: [5,1,4,null,null,3,6]Output: false Explanation: The root node’s value is 5 but its right child’s value is 4. approach 1:中序遍历遍历后存到array,判断array是否为升序 算法1234567891011121314151617181920212223242526class Solution { public boolean isValidBST(TreeNode root) { if (root == null) { return true; } List&lt;TreeNode&gt; list = inorder(root, new ArrayList&lt;TreeNode&gt;()); for (int i = 0; i &lt; list.size()-1; i++) { if (list.get(i).val &gt;= list.get(i + 1).val) { return false; } } return true; } private List&lt;TreeNode&gt; inorder(TreeNode root, ArrayList&lt;TreeNode&gt; list) { if (root == null) { return list; } inorder(root.left, list); list.add(root); return inorder(root.right, list); }} 123456789101112131415161718192021/* 中序遍历,在比较中返回 */class Solution { TreeNode pre; public boolean isValidBST(TreeNkkode root) { if (root == null) { return true; } if(!isValidBST(root.left)){ return false; } if (pre != null &amp;&amp; root.val &lt;= pre.val) { return false; }kk pre = root; if(!isValidBST(root.right)){ return false; } return true; }} 复杂度 time:O(n) space:O(n) approach 2:递归根据定义,对于左边的右边节点,他的下界是根节点,上界是父节点;右边的左边节点的下界是父节点,上界是父节点 算法1234567891011121314151617181920212223242526class Solution { public boolean isValidBST(TreeNode root) { return helper(root, Long.MIN_VALUE, Long.MAX_VALUE); } private boolean helper(TreeNode root, long min, long max) { if (root == null) { return true; } if (!helper(root.left, min, root.val)) { return false; } if (root.val &lt;= min || root.val &gt;= max) { return false; } if (!helper(root.right, root.val, max)) { return false; } return true; }} 12345678910111213141516171819202122class Solution { public boolean isValidBST(TreeNode root) { return helper(root, null, null); } private boolean helper(TreeNode root, Integer min, Integer max) { if (root == null) { return true; } if ((min != null &amp;&amp; root.val &lt;= min)) { return false; } if (max != null &amp;&amp; root.val &gt;= max) { return false; } return helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max); }} 复杂度 time:O(n) space:O(n)","link":"/2019/07/19/18-验证二叉搜索树:leetcode-98/"},{"title":"17.树和图","text":"树树是特殊化的链表 无单个子节点–完全二叉树 二叉搜索树也称有序二叉树，排序二叉树，是指一颗空树或者具有下列性质的二叉树： 左子树上所有节点的值均小于他的根节点（!!!注意：是左右子树，不是左儿子右儿子） 右子树上所有节点的值均大于他的根节点 递推地，左右子树也分别为二叉查找树 查找的平均时间复杂度为从O(n)变为O(logn),最坏情况(只有右子树)退化为O(n); 平衡二叉树,如红黑树,avl树,kd树最坏情况为O(logn) 图 图是特殊化的树指回根节点–图","link":"/2019/07/19/17-树和图/"},{"title":"20.二叉树的遍历","text":"123456789101112131415public class preorder{ private List&lt;TreeNode&gt; list; public List&lt;TreeNode&gt; inorder(TreeNode root){ if(root ==null){ return null; } inorder(root.left); list.add(root); inorder(root.right); return list; }}","link":"/2019/07/19/20-二叉树的遍历/"},{"title":"19.二叉树_最近公共祖先:leetcode236","text":"problemGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3. Example 2: 12Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the binary tree. approach 1:递归算法12345678910111213141516171819class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || p == root || q == root) { return root; } TreeNode leftResult = lowestCommonAncestor(root.left, p, q); TreeNode rightResult = lowestCommonAncestor(root.right, p, q); if (leftResult != null &amp;&amp; rightResult != null) { return root; } if (leftResult == null) { return rightResult; } if (rightResult == null) { return leftResult; } return null; }} 复杂度 time:O(n) space:O(n)","link":"/2019/07/19/19-二叉树_最近公共祖先:leetcode236/"},{"title":"23.分治：leetcode-169","text":"problemGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: 123456Input: [3,2,3]Output: 3Example 2:Input: [2,2,1,1,1,2,2]Output: 2 approach1:123456class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; }} 复杂度 time:O(nlogn) space:O(1) approach2:12345678910111213141516171819class Solution { public int majorityElement(int[] nums) { HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; for (int num : nums) { if (!map.containsKey(num)) { map.put(num, 1); } else { map.put(num, map.get(num) + 1); } if (map.get(num) &gt; nums.length / 2) { res = num; break; } } return res; }} 复杂度 time:O(n) space:O(n) approach3:12345678910111213141516171819// 每次都找出一对不同的元素，从数组中删掉，直到数组为空或只有一种元素。// 不难证明，如果存在元素e出现频率超过半数，那么数组中最后剩下的就只有e。// [1,2,3,3,3]class Solution { public int majorityElement(int[] nums) { int res = 0; int count = 0; for (int num : nums) { if (count == 0) { res = num; } if (res != num) { count--; } else count++; } return res; }} 复杂度 time:O(n) space:O(1) approach4:分治算法","link":"/2019/09/17/23-分治：leetcode-169-1/"},{"title":"25.贪心算法:leetcode122","text":"problemSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). 123456789101112131415161718Example 1:Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Example 2:Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3:Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. approach1:1234567891011class Solution { public int maxProfit(int[] prices) { int profit = 0; for (int i = 0; i &lt; prices.length - 1; i++) { if (prices[i + 1] &gt; prices[i]) { profit += prices[i + 1] - prices[i]; } } return profit; }} 复杂度 time:O(n) space:O(1) approach2:12 复杂度 time:O() space:O() approach3:12 复杂度 time:O() space:O()","link":"/2019/09/17/25-贪心算法-leetcode122/"},{"title":"26.广度优先&深度优先","text":"广度优先 深度优先","link":"/2019/09/17/26-广度优先-深度优先/"},{"title":"21.递归和分治:leetcode-50","text":"Implement pow(x, n). eg. 2^2 = 2^1 * 2^1 = (2^0 * 2^0 * 2) * (2^0 * 2^0 * 2) = (1 * 1 * 2) * (1 * 1 * 2) = 4 eg. 2^3 = 2^1 * 2^1 * 2 = (2^0 * 2^0 * 2) * (2^0 * 2^0 * 2) * 2 = (1 * 1 * 2) * (1 * 1 * 2) * 2 = 8 注意：负数的int的取值范围为-2^31~2^31-1,如果直接使用-n会导致栈溢出 approach1123456789101112131415161718class Solution { public double myPow(double x, int n) { return pow(x, n); } private static double pow(double x,long n) { if (n == 0) { return 1; } if (n &lt; 0) { return 1 / pow(x, -n); } if (n % 2 == 1) { return x * pow(x * x, n / 2); } return pow(x * x, n / 2); }} time: O(logn)space: O(logn) approach2123456789101112131415161718public static double myPow2(double x, int n) { if (n == 0) return 1; double res = 1; // int : -6.. ~ +6.. -2^32 ~ 2 ^32-1 Integer.MIN_VALUE long abs = Math.abs((long)n); while (abs &gt; 0) { if (abs % 2 != 0) { res *= x; } x *= x; abs /= 2; } if (n &lt; 0) { return 1.0 / res; } return res;} time: O(logn)space: O(1)","link":"/2019/09/05/21-递归和分治/"},{"title":"29.二叉树的最大深度:leetcode104","text":"problemGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. 12345678910Example:Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its depth = 3. approach1:深度优先 123456789class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); }} 复杂度 time:O(n) space:O(n)","link":"/2019/09/17/29-二叉树的最大深度-leetcode104/"},{"title":"29.二叉树的最小深度:leetcode111","text":"problemGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. 12345678910Example:Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its minimum depth = 2. approach1:12345678910111213class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } if (root.left == null || root.right == null) { return Math.max(minDepth(root.left), minDepth(root.right)) + 1; } return Math.min(minDepth(root.left), minDepth(root.right)) + 1; }} 复杂度 time:O(n) space:O(n)","link":"/2019/09/17/29-二叉树的最小深度-leetcode111/"},{"title":"30.有效括号生成：leetcode22","text":"problemGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. 123456789For example, given n = 3, a solution set is:[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] approach1深度优先搜索 12345678910111213141516171819202122class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res, \"\", n, 0, 0); return res; } private void helper(List&lt;String&gt; res, String s, int n, int left, int right) { if (right == n) { res.add(s); return; } if (left &lt; n) { helper(res, s + \"(\", n, left + 1, right); } if (right &lt; left) { helper(res, s + \")\", n, left, right + 1); } }} time:O(n!) O(2^n) 卡特兰数 space:O(n)","link":"/2019/09/18/30-有效括号生成：leetcode22/"},{"title":"35.二分查找：leetcode69","text":"1234567891011left, right =0, len(array) - 1while left &lt;= right: mid = left + (right - left)/2 if array[mid] == target: //find the target break or return result elif array[mid] &lt; target: left = mid + 1 else: right = mid - 1 problemImplement int sqrt(int x). approach1单调递增可以用二分法 12 time:O() space:O() approach212 time:O() space:O() approach312 time:O() space:O() summery","link":"/2019/09/18/35-二分查找：leetcode69/"},{"title":"Fibonacci","text":"斐波那契递归F(n) = F(n-1) + F(n-2) 1234def fib(n): if n==0 or n==1: return n return fib(n-1) + fib(n-2) 时间复杂度2^n 主定律 算法 时间 二分查找 O(logn) 二叉树遍历 O(n) 快速排序/归并排序 O(nlog(n))","link":"/2019/07/09/Fibonacci/"},{"title":"Java多线程和并发-原理","text":"synchronized线程安全的主要诱因 存在共享数据 存在多条线程共同操作这些共享数据 根本方法:同一时刻有且只有一个线程在操作共享数据,其他线程必须等到该线程处理完数据后再对共享数据进行操作 互斥锁的特性 互斥性:同一时间只允许一个线程持有某个对象锁 可见性:锁被释放前,对共享变量所做的修改,对于随后获得该锁的线程是可见的 synchronized锁的是对象而不是代码 获取的锁的分类:获取对象锁和获取类锁获取对象锁的两种方法: 同步代码块,synchronized(this),synchronized(类实例对象) 同步非静态方法(synchronized method),锁的是当前对象的实例对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class SyncThread implements Runnable { @Override public void run() { String threadName = Thread.currentThread().getName(); if (threadName.startsWith(\"A\")) { async(); } else if (threadName.startsWith(\"B\")) { syncObjectBlock1(); } else if (threadName.startsWith(\"C\")) { syncObjectMethod1(); } else if (threadName.startsWith(\"D\")) { syncClassBlock1(); } else if (threadName.startsWith(\"E\")) { syncClassMethod1(); } } /** * 异步方法 */ private void async() { try { System.out.println(Thread.currentThread().getName() + \"_Async_Start: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"_Async_End: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); } catch (InterruptedException e) { e.printStackTrace(); } } /** * 方法中有 synchronized(this|object) {} 同步代码块 */ private void syncObjectBlock1() { System.out.println(Thread.currentThread().getName() + \"_SyncObjectBlock1: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); synchronized (this) { try { System.out.println(Thread.currentThread().getName() + \"_SyncObjectBlock1_Start: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"_SyncObjectBlock1_End: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * synchronized 类锁 */ private synchronized void syncObjectMethod1() { System.out.println(Thread.currentThread().getName() + \"_SyncObjectMethod1: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); try { System.out.println(Thread.currentThread().getName() + \"_SyncObjectMethod1_Start: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"_SyncObjectMethod1_End: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); } catch (InterruptedException e) { e.printStackTrace(); } } /** * synchronized 修饰非静态方法 */ private void syncClassBlock1() { System.out.println(Thread.currentThread().getName() + \"_SyncClassBlock1: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); synchronized (SyncThread.class) { try { System.out.println(Thread.currentThread().getName() + \"_SyncClassBlock1_Start: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"_SyncClassBlock1_End: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * synchronized 修饰静态方法 */ private synchronized static void syncClassMethod1() { System.out.println(Thread.currentThread().getName() + \"_SyncClassMethod1: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); try { System.out.println(Thread.currentThread().getName() + \"_SyncClassMethod1_Start: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"_SyncClassMethod1_End: \" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); } catch (InterruptedException e) { e.printStackTrace(); } }} 对象锁和类锁的总结 synchronized底层实现原理实现synchronized的基础 Java对象头 对象在内存中的布局(对象头,实例数据,对齐填充) Monitor 每个Java对象天生自带了一把看不见的锁,存在Java对象的对象头中 ObjectMonitor实现: 每个对象锁的线程会被封装成ObjectWaiter存入EntryList synchronized历史 自旋锁:等待锁释放,不让出cpu 自适应自旋锁:自旋锁线程的等待时间和次数不固定 锁消除 锁粗化 synchronized的四种状态 synchronized和reentrantLockReentrantLock(再入锁) synchronized和reentrantLock公平性的设置 1234567891011121314151617181920212223242526public class ReentrantLockDemo implements Runnable{ private static ReentrantLock lock = new ReentrantLock(false); @Override public void run(){ while (true){ try{ lock.lock(); System.out.println(Thread.currentThread().getName() + &quot; get lock&quot;); Thread.sleep(1000); } catch (Exception e){ e.printStackTrace(); } finally { lock.unlock(); } } } public static void main(String[] args) { ReentrantLockDemo rtld = new ReentrantLockDemo(); Thread thread1 = new Thread(rtld); Thread thread2 = new Thread(rtld); thread1.start(); thread2.start(); }}//输出交替 总结 JMM的内存可见性java内存模型内存模型规定了多线程程序读写操作规范 java内存模型(java memory model)描述的是一组规范,定义了程序中各个变量的访问方式 线程对变量的操作必须在本地内存中执行,线程先把变量从主内存拷贝到工作内存,然后对变量进行操作,再拷贝到主内存中,线程之间的通信必须通过主内存 JMM中的主内存 存储Java实例对象 包括成员变量,类信息,常量,静态变量等 属于数据共享的区域,多线程并发操作时会引发线程安全问题 JMM中的工作内存 储存当前方法的所有本地变量信息,#本地变量对其他线程不可见 字节码行号指示器,Native方法信息 数据线程私有数据区域,不存在线程安全问题 JMM与java内存划分是不同的概念层次 JMM描述的是一组规则,围绕原子性,有序性,可见性展开 相似点:存在共享区域和私有区域 主内存与工作内存的数据存储类型以及操作方式归纳 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中 引用类型的本地变量:引用存储在工作内存中,实例存储在主内存中 成员变量,static变量,类信息均会被储存到主内存中 主内存共享的方式是线程各拷贝一份数据到工作内存中,操作完成后再刷新回主内存 JMM怎么解决可见性问题 指令重新排序需要满足的条件 A操作的结果对B操作可见,则A与B存在happens-before的关系 happens-before的概念 volatile:JVM提供的轻量级同步机制 volatile修饰的变量对所有线程总是可见的 禁止指令重排 多线程操作可能引发线程安全=&gt; synchronized也具有可见性,可以省略volatile=&gt; volatile如何实现可见性 volatile如何禁止重排优化-（内存屏障，以及保证内存可见性） 单例是双重检测实现123456789101112131415161718192021222324252627282930public class Singleton{ // 所以要加volatile关键字 private volatile static Singleton instance; private Singleton(){} public static Singleton getInstance(){ //问题:Ａ判断为空后进入但还未实例化Ｂ也判断为空 if(intstance==null){ instance=new Singleton(); } //问题：AB都判断为空，A先实例化，B拿到锁又实例化 if(instance==null){ synchronized(Singleton.class){ instance=new Singleton(); } } //问题：1.指令重排后,线程A未初始化对象,但instance指向了刚分配的内存空间,instance!=null,B线程可能拿到一个未成品 2:线程A初始化完对象,但还未刷入主存,线程B可能还会初始化一个实例 if(instance==null){ synchronized(Singleton.class){ if(instance==null){ instance= new Singleton(); } } } }} CAS(Compare and Swap) java线程池利用Executors创建不同的线程池满足不同场景的需求 使用双端队列实现 为什么要使用线程池 降低资源消耗 提高线程的可管理性 Executor的框架 线程池的基本组成: corePoolSize:核心线程数量(长期驻留的线程数) maximumPoolSize:线程不够用时能创建的最大线程数 workQueue:任务等待队列 keepAliveTime:非核心线程等待时间 threadFactory:创建新线程 handler:线程池饱和策略(阻塞队列满了并且没有空闲线程) 线程池的状态 流程图 生命周期 线程池的大小如何选定","link":"/2019/07/26/Java多线程和并发-原理/"},{"title":"Java多线程和并发","text":"进程和线程的区别//TODO linux用户态和内核态是如何进行转换,为什么要转换,什么是系统中断,它的内核态的多线程是如何通过轻量级线程方式实现 线程和进程的由来 线程和进程的区别进程是资源分配的最小单位,线程是CPU调度的最小单位 所有进程相关资源都被记录在PCB(进程控制块)中 进程是抢占处理机的调度单位;线程属于某个进程,共享其资源 线程只由堆栈寄存器,程序计数器和线程控制块TCB组成 总结 java进程和线程的关系 一个程序是一个可执行的文件,一个进程是一个执行中的程序的实例.jvm是多线程的,如垃圾收集器的线程 线程的start和run方法的区别1234567891011121314151617public class ThreadTest { private static void attack() { System.out.println(&quot;fight&quot;); System.out.println(&quot;current thread is:&quot; + Thread.currentThread().getName()); } public static void main(String[] args) { Thread t = new Thread() { public void run() { attack(); } }; System.out.println(&quot;current main thread is:&quot; + Thread.currentThread().getName());// t.run();//main t.start();//thread-0 } run方法只是Thread的一个普通方法的调用,还是在主线程里执行 调用start方法会创建一个新的子线程 Thread和Runnable是什么关系1234567891011121314151617181920212223242526public class ThreadDemo { public static void main(String[] args) { MyThread mt1 = new MyThread(&quot;thread1&quot;); MyThread mt2 = new MyThread(&quot;thread2&quot;); MyThread mt3 = new MyThread(&quot;thread3&quot;); mt1.start(); mt2.start(); mt3.start(); }}public class MyThread extends Thread { private String name; public MyThread(String name) { this.name = name; } @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(&quot;Thread start:&quot; + this.name + &quot;,i=&quot; + i); } }}//输出是交替执行的,说明是多线程 12345678910111213141516171819202122232425262728public class RunnableDemo { public static void main(String[] args) { MyRunnable mr1 = new MyRunnable(&quot;runnable1&quot;); MyRunnable mr2 = new MyRunnable(&quot;runnable2&quot;); MyRunnable mr3 = new MyRunnable(&quot;runnable3&quot;); Thread t1 = new Thread(mr1); Thread t2 = new Thread(mr2); Thread t3 = new Thread(mr3); t1.start(); t2.start(); t3.start(); }}public class MyRunnable implements Runnable { private String name; public MyRunnable(String name) { this.name = name; } @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(&quot;Thread start:&quot; + this.name + &quot;,i=&quot; + i); } }}//输出是交替执行的,说明是多线程 Thread是一个实现了Runnable的类,使得run支持多线程 因类的单一继承原则,推荐使用Runnable接口 如何给run()方法传参 如何实现处理线程的返回值（主线程等待，join，callable，线程池） 1.主线程等待 1234567891011121314151617181920212223242526public class CycleWait implements Runnable { private String val; @Override public void run() { try { Thread.currentThread().sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } val = &quot;we have data now&quot;; } public static void main(String[] args) throws InterruptedException { CycleWait cw = new CycleWait(); Thread t = new Thread(cw); t.start(); while (cw.val == null) { Thread.currentThread().sleep(100); } //t.join(); System.out.println(cw.val); }} 2.使用Thread类的join()阻塞当前线程以等待子线程处理完毕(无法更精细) 缺点:无法更精细,如上例中多个Runnable,无法做到当Runnable1的i=5 再执行Runnable2 3.通过Callable借口实现:通过FutureTask Or 线程池获取 12345678910public class MyCallable implements Callable&lt;String&gt; { @Override public String call() throws Exception { String val = &quot;test&quot;; System.out.println(&quot;ready to work&quot;); Thread.currentThread().sleep(4000); System.out.println(&quot;Work is done&quot;); return val; }} 1234567891011121314151617方式1:通过FutureTaskpublic class FutureTaskDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new MyCallable()); new Thread(futureTask).start(); if (!futureTask.isDone()) { System.out.println(&quot;Please wait&quot;); } System.out.println(&quot;Task return:&quot; + futureTask.get()); }}输出:Please waitready to workWork is doneTask return:test 12345678910111213141516171819202122方式二:通过线程池public class ThreadPoolDemo { public static void main(String[] args) { ExecutorService newCachethreadPool = Executors.newCachedThreadPool(); Future&lt;String&gt; future = newCachethreadPool.submit(new MyCallable()); if (!future.isDone()) { System.out.println(&quot;Please wait&quot;); } try { System.out.println(&quot;Task return:&quot; + future.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } finally { newCachethreadPool.shutdown(); } }} 进程状态 1.新建(New):创建后尚未启动 2.运行(Runnable):包含Running和Ready,可能正在执行,也可能在等待cpu分配时间 3.无限期等待(Waiting):不会被分配cpu执行时间,需要被显示唤醒 4.限期等待(Timed Waiting):在一定时间后会由系统自动唤醒 5.阻塞(Blocked):等待获取排他锁 6.结束(Terminated):已终止线程的状体,线程已经结束执行 sleep和wait的区别基本的差别 sleep是Thread的方法,而wait是Object的方法 sleep方法可以在任何地方使用;wait只能在synchronize方法或者synchronized块中使用(获取锁才能释放锁) 最主要区别 Thread.sleep会让出cpu,不会让出锁 Object.wait会让出cpu,还会让出锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class WaitSleepDemo { public static void main(String[] args) { final Object lock = new Object(); new Thread(new Runnable() { @Override public void run() { System.out.println(\"Thread A wait for lock\"); synchronized (lock) { try { System.out.println(\"Thread A get lock\"); Thread.sleep(20); System.out.println(\"Thread A do wait method\"); lock.wait(1000); System.out.println(\"Thread a is done\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); //保证前一个线程先执行 try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(new Runnable() { @Override public void run() { System.out.println(\"Thread B wait for lock\"); synchronized (lock) { try { System.out.println(\"Thread B get lock\"); System.out.println(\"Thread B is sleeping\"); Thread.sleep(10); System.out.println(\"Thread B is done\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); }}输出:Thread A wait for lockThread A get lockThread B wait for lockThread A do wait methodThread B get lockThread B is sleepingThread B is doneThread A is done notify和notifyall的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class WaitSleepDemo { public static void main(String[] args) { final Object lock = new Object(); new Thread(new Runnable() { @Override public void run() { System.out.println(\"Thread A wait for lock\"); synchronized (lock) { try { System.out.println(\"Thread A get lock\"); Thread.sleep(20); System.out.println(\"Thread A do wait method\"); lock.wait(); System.out.println(\"Thread A is done\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(new Runnable() { @Override public void run() { System.out.println(\"Thread B wait for lock\"); synchronized (lock) { try { System.out.println(\"Thread B get lock\"); System.out.println(\"Thread B is sleeping\"); Thread.sleep(10); System.out.println(\"Thread B is done\"); lock.notify(); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); }}输出:Thread A wait for lockThread A get lockThread B wait for lockThread A do wait methodThread B get lockThread B is sleepingThread B is done //notify通知AThread A is done 两个概念 锁池EntryList 等待池WaitSet 区别 yeild当调用yeild方法时,会暗示线程调度器当前线程愿意让出cpu,但是线程调度器有可能会忽略这个暗示 yeild对锁不会有影响 如何中断线程已经被抛弃的方法 目前使用的方法调用interupt(),通知线程应该中断了 1.如果线程处于被阻塞的状态(如sleep,wait,join),那么线程将立刻退出被阻塞的状态,并且抛出一个InterruptedException异常 2.如果线程处于活动状态,那么将该线程的中断标志设置为true.被设置中断标志的线程将继续正常运行,不受影响 3.需要调用线程配合中断:经常检查本线程的中断标志位,如果被设置了中断标志就自行停止线程;在调用阻塞方法的时候,捕获InterruptedException 123456789101112131415161718192021222324252627282930313233343536public class InterruptDemo { public static void main(String[] args) throws InterruptedException { Runnable interruptTask = new Runnable() { @Override public void run() { int i = 0; try { //在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程 while (!Thread.currentThread().isInterrupted()) { Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName() + \" (\" + Thread.currentThread().getState() + \") loop \" + i); } } catch (InterruptedException e) { //在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。） System.out.println(Thread.currentThread().getName() + \" (\" + Thread.currentThread().getState() + \") catch InterruptedException.\"); } } }; Thread t1 = new Thread(interruptTask, \"t1\"); System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\"); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\"); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +\" (\"+t1.getState()+\") is interrupted.\"); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +\" (\"+t1.getState()+\") is interrupted now.\"); }} 1234567t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (TERMINATED) is interrupted now. 线程状态及状态之间的转换","link":"/2019/07/24/Java多线程和并发/"},{"title":"Java常用类库","text":"Java异常体系Error和Exception的区别 Error:程序无法处理的系统错误,编译器不做检查 Exception:程序可以处理异常,捕获后可以恢复 总结:前者程序无法处理,后者是可以处理的异常 常见Error和Exception 异常处理体系 finally会在catch块里的return前执行 异常处理原则 高效的异常处理框架 try-catch的性能 Java集合框架 集合之List和Set 集合之MapHashMap,HashTable,ConccurentHashMap的区别 java8以后,hashMap中的元素为Node &lt;k,v&gt;[]&lt;/k,v&gt; 将Map变成线程安全的 原理和HashTable一样 1Collections.synchronizedMap(hashMap); 如何优化Hashtable? 通过锁的细粒度化,将锁拆解为多个锁进行优化 只锁定当前链表或者红黑树的首个节点来实现 sizeCtl:负数代表正在初始化,-1正在初始化,-n n-1 个线程在扩容,正数还未初始化 Java的IO机制BIO,NIO,AIO的区别","link":"/2019/08/13/Java常用类库/"},{"title":"Java底层:GC","text":"标记算法引用计数算法（不适合循环引用） 通过判断对象的引用数量来决定对象是否可以被回收 每个对象实例都有一个引用计数器,被引用则+1,完成引用则-1 任何引用计数为0的对象实例可以被当做垃圾收集 优点: 执行效率高,程序执行受影响较小 缺点: 无法检测出循环引用的情况,导致内存泄露 可达性分析算法通过判断对象的引用链是否可达来决定对象是否可以被回收 可以作为GCRoot的对象 垃圾回收算法标记-清除算法（碎片化） 标记:从根集合进行扫描,对存货的对象进行标记 清除:对堆内存从头到尾进行线性遍历,回收不可达对象 缺点:不需要进行对象的移动，碎片化严重。如果下一次需要新建一个大的对象，位置不够 复制算法（年轻代） 分为对象面和空闲面 对象在对象面上创建，存活对象从对象面复制到空闲面，再将对象面的所有对象清除 解决了碎片化问题 顺序分配内存,简单高效 适用于对象存活率低的场景 适用于年轻代(存活对象少) 标记-整理算法（老年代） 标记:从根集合进行扫描,对存货的对象进行标记 清除:移动所有存活的对象,且按照内存地址依次排列,然后将末端内存地址以后的内存全部回收 避免内存的不连续 不用设置两块内存互换 适用于存活率高的场景,如老年代 分代收集算法 垃圾回收算法的组合拳 按照对象生命周期的不同划分区域采用不同的垃圾回收算法 目的:提高JVM的回收效率 GC的分类 Minor GC 发生在年轻代,采用复制算法 Full GC 与老年代相关,一般老年代的回收伴随着年轻代的回收,因此称为FullGC 年轻代:尽可能快速地收集掉那些生命周期短的对象 Eden区（伊甸园） 两个Survivor区（from&amp;to）8：1：1 年轻代垃圾回收过程: eden满了，触发mirror-gc，将存活对象复制到survivor 清理eden区 eden再次满了，将eden和s0中的对象拷贝到s1，年龄加1，清理eden和s0 eden再次满了，将eden和s1中的对象拷贝到s0，年龄加1，清理eden和s1 当对象的年龄超过一定岁数,变为老年代,可通过参数调节 对象如何晋升到老年代 经历一定Minor次数仍然存活 Survivor区中放不下的对象 新生成的大对象(-XX:+PretenuerSizeThreshold) 常用调优参数 老年代:存放生命周期较长的对象大概比例1：2 FullGC和MajorGC FullGC比MinorGC慢（10倍）,但执行频率低 触发fullGC方条件: 老年代空间不足 MinorGC晋升到老年代的平均大小大于老年代的剩余空间 永久代空间不足(JDK7之前，这也是用元空间替代永久代的原因,降低fullGC的频率) 调用System.gc()(这个方法不一定执行) CMS GC时出现promotion failed,concurrent mode failure 使用RMI来进行RPC或者管理的JDK应用,每小时执行一次FullGC 垃圾收集器 stop-the-world Safepoint(回收垃圾要提醒不要扔垃圾) JVM的运行模式 Server(启动慢,稳定后比Client快) Client 垃圾收集器的联系 年轻代常见收集器 除了Serial只有它能和CMS配合,Server下的首选的收集器 老年代常见收集器 对停顿不敏感,硬件好,更多存活时间长的对象选择CMS;碎片化 GC常见面试题Object的finalize()方法的作用是否与C++的析构函数作用相同 12345678910111213public static void main(String[] args) { Finalization f = new Finalization(); System.out.println(&quot;First print: &quot; + f); f = null; System.gc(); try {// 休息一段时间，让上面的垃圾回收线程执行完成 Thread.currentThread().sleep(1000); } catch (InterruptedException e){ e.printStackTrace(); } System.out.println(&quot;Second print: &quot; + f); System.out.println(f.finalization);} java中的强引用,软引用,弱引用,虚引用有什么用强引用 软引用 弱引用 虚引用","link":"/2019/07/24/Java底层-gc/"},{"title":"Java底层:JVM","text":"谈谈你对java的理解 平台无关性 GC 语言特性 面向对象 类库 异常处理 平台无关如何实现java源码首先被编译成字节码,再由不同平台的jvm进行解析,java语言在不同平台上运行时不需要重新编译,java虚拟机在执行字节码时,把字节码转换为具体平台上的机器指令 为什么jvm不直接将源码解析成机器码去执行 每次执行需要重新编译,进行语法检查语义分析等,性能就会受影响 别的语言也可以解析成字节码 jvm如何加载.class文件 jvm主要由ClassLoader,RuntimeDataArea,ExecutionEngine,NativeInterface这四部分组成,它通过classloader将符合特定格式的class文件加载到内存,再通过executionEngine对命令进行解析,并提交给操作系统执行 谈谈反射 写一个例子1234567891011121314151617181920public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { Class rc = Class.forName(&quot;com.test.basic.Robot&quot;); Robot r = (Robot) rc.newInstance(); System.out.println(&quot;class name is :&quot; + rc.getName()); Method getHello = rc.getDeclaredMethod(&quot;throwHello&quot;, String.class); getHello.setAccessible(true); Object str = getHello.invoke(r, &quot;bob&quot;); System.out.println(&quot;get hello result:&quot; + str); Method sayHi = rc.getMethod(&quot;sayHi&quot;, String.class); sayHi.invoke(r, &quot;welcom&quot;); Field name = rc.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(r, &quot;dd&quot;); sayHi.invoke(r, &quot;welcome&quot;); } 类从编译到执行的过程 谈谈classloader classloader的种类 自定义classloader的实现关键函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyClassLoader extends ClassLoader { private String path; private String classLoaderName; public MyClassLoader(String path, String classLoaderName) { this.path = path; this.classLoaderName = classLoaderName; } @Override protected Class findClass(String name) { byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); } private byte[] loadClassData(String name) { name = path + name + &quot;.class&quot;; InputStream in = null; ByteArrayOutputStream out = null; try { in = new FileInputStream(new File(name)); out = new ByteArrayOutputStream(); int i = 0; while ((i = in.read()) != -1) { out.write(i); } } catch (IOException e) { e.printStackTrace(); } finally { try { in.close(); out.close(); } catch (IOException e) { e.printStackTrace(); } } return out.toByteArray(); }}public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { MyClassLoader myClassLoader = new MyClassLoader(&quot;/home/zw/Documents/&quot;,&quot;Wali&quot;); Class c = myClassLoader.loadClass(&quot;Wali&quot;); System.out.println(c.getClassLoader()); c.newInstance(); } 谈谈类加载的双亲委派机制 为什么使用双亲委派机制避免多份同样的字节码的加载 类加载的方式 隐式加载:new 显式加载:loadClass,forName等 loadClass和forName的区别 类的装载过程 区别:forName得到的class是完成初始化的,loadClass得到的class还没有链接 1234public static void main(String[] args) throws ClassNotFoundException {// ClassLoader cl = Robot.class.getClassLoader(); Class c = Class.forName(&quot;com.test.basic.Robot&quot;);} forName用于需要执行初始化的类,loadClass用于延时加载,加快加载速度 Java的内存模型内存简介 地址空间的划分 java的内存空间在用户空间 内存空间即RuntimeDataArea 程序计数器(Program Counter Register) 程序计数器是逻辑计数器,为了线程切换后都能恢复正确的执行位置,每个线程都有独立的程序计数器,并且只为java方法计数 java虚拟机栈(Stack) 虚拟机栈包含了单个线程每个方法执行的栈帧,栈帧存储了局部变量表,操作栈,动态连接,方法出口 局部变量表和操作数栈 局部变量表为操作数栈提供数据支撑 递归为什么会导致StackOverFlow异常 递归过深,栈帧超出虚拟栈深度 虚拟机栈过多会引发OutOfMemory异常本地方法栈与虚拟机栈类似,主要作用于标注了native的方法 元空间(MetaSpace)与永久代(PermGen)在jdk7以后,把类的元数据放在本地堆内存中,这块区域叫MetaSpace,该区域在jdk7以前属于永久代,二者都是用来储存class的相关信息,包括class对象的method,filed. 元空间和永久代都是方法区的实现,方法区只是jvm的规范. 在java7之后,原先位于方法区的字符串常量池被移动到java堆中,并且在java8后使用元空间替换永久代. 元空间使用的本地内存,而永久代使用的是jvm的内存. 这样的好处是解决了空间不足,其大小是动态分配的 元空间内存空间使用的是本机内存,没有了字符串常量池(java7后被移动到了堆中),永久代的空间有限 java堆(Heap) JVM三大性能调优参数-Xms -Xmx -Xss的含义1java -Xms128m -Xmx128m -Xss256k -jar xxx.jar Xss:规定了每个线程虚拟机栈(堆栈)的大小(一般情况256k足够,将会影响并发线程数的大小) Xms:堆的初始值(一旦对象容量超过java堆的容量,会进行扩容) Xmx:堆能达到的最大值(一般情况设置成和xms一致,不会发生抖动) java内存模型中堆和栈的区别内存分配策略 联系 区别 管理方式:栈自动释放,堆需要GC 空间大小:栈比堆小 碎片相关:栈产生的碎片远小于堆 分配方式:栈支持静态和动态分配,而堆只支持动态分配 效率:栈的效率比堆高 元空间,堆,线程独占部分空间的联系-内存角度 不同JDK版本之间intern()方法的区别-JDK6 VS JDK6+12String s = new String(&quot;a&quot;);s.intern(); jdk6+不仅能在池中添加对象,还能在池中添加堆中的引用 jdk6:flase false jdk6+:false true","link":"/2019/07/23/Java底层-jvm/"},{"title":"Java框架-Spring","text":"SpringIOC (Inversion of Control) 控制反转 SpringCore最核心部分 需要先了解依赖注入(DependencyInversion) DI举例设计行李箱 IOC,DI,DL的关系 依赖注入的方式 Setter Interface Constructor Annotation 依赖倒置原则,IOC,DI,IOC容器的关系 IOC容器的优势 避免在各处使用new来创建类,并且可以做到同一维护 创建实例时不需要了解细节 spring的IOC容器 SpringIOC支持的功能 SpringIOC容器的核心接口 BeanFactory ApplicationContext BeanDefinition-描述Bean的定义 BeanDefinitionRegistry-提供向容器注册BeanDefinition对象的方法BeanFactory和ApplicationContext的比较 BeanFactory是Spring框架的基础设施,面向Spring ApplicationContext面向开发者 spring比作汽车,BeanFactory就是发动机,而ApplicationContext是完整的汽车 ApplicationContext的功能(继承多个接口) GetBean方法的解析 Spring的作用域 SpringBean的生命周期创建过程 销毁过程 AOP AOP的三种织入方式 Advice的种类 AOP的原理AOP的实现:JDKProxy和Cglib 代理模式:接口+真实实现类+代理","link":"/2019/08/13/Java框架-Spring/"},{"title":"fabric部署过程","text":"","link":"/2019/09/19/fabric部署过程/"},{"title":"57.布隆过滤器","text":"Bloom Filter一个很长的二进制向量和一个映射函数 布隆过滤器可以用于检索一个元素是否存在一个集合中 优点是空间效率和查询效率远超一般算法，缺点是有一定的误识别率和删除困难 案例 比特币： 查询交易记录。先利用布隆过滤器查询是否存在记录 分布式系统：判断子任务是否在一台机器上存在","link":"/2019/09/18/57-布隆过滤器/"},{"title":"leetcode 141. Linked List Cycle","text":"Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list. 方法1：hashtable 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { Set set = new HashSet(); ListNode cur = head; while(cur!=null &amp;&amp; cur.next!=null){ if(set.contains(cur.next)){ return true; } set.add(cur.next); cur= cur.next; } return false; }} 方法2：快慢指针 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while(fast!=null &amp;&amp; fast.next!=null){ slow = slow.next; fast = fast.next.next; if(slow == fast){ return true; } } return false; }}","link":"/2019/07/10/leetcode 141. Linked List Cycle/"},{"title":"leetcode 20. Valid Parentheses","text":"Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]{}&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;{[]}&quot;Output: true 方法1： 12345678910111213141516171819class Solution { public boolean isValid(String s) { Map&lt;Character,Character&gt; m = new HashMap&lt;Character,Character&gt;(); m.put(&apos;)&apos;, &apos;(&apos;); m.put(&apos;}&apos;, &apos;{&apos;); m.put(&apos;]&apos;, &apos;[&apos;); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char key : s.toCharArray()) { if (!m.containsKey(key)) { stack.push(key); } else if (stack.empty() || !m.get(key).equals(stack.pop())) { return false; } } return stack.empty(); }}","link":"/2019/07/10/leetcode 20. Valid Parentheses/"},{"title":"leetcode 232. Implement Queue using Stacks","text":"Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue.pop() – Removes the element from in front of queue.peek() – Get the front element.empty() – Return whether the queue is empty. Example: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class MyQueue { Stack&lt;Integer&gt; input = new Stack();; Stack&lt;Integer&gt; output = new Stack(); /** Initialize your data structure here. */ public MyQueue() { } /** Push element x to the back of queue. */ public void push(int x) { input.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { copy(); return output.pop(); } /** Get the front element. */ public int peek() { copy(); return output.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return input.empty() &amp;&amp; output.empty(); } private void copy(){ if(output.empty()){ while(!input.empty()){ output.push(input.pop()); } } }}/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","link":"/2019/07/10/leetcode 232. Implement Queue using Stacks/"},{"title":"leetcode 206. Reverse Linked List","text":"Reverse a singly linked list. 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseList(ListNode head) { ListNode cur = head; ListNode prev = null; while(cur!=null){ ListNode lat = cur.next; cur.next = prev; prev = cur; cur = lat; } return prev; } }","link":"/2019/07/10/leetcode 06. Reverse Linked List/"},{"title":"leetcode 24. Swap Nodes in Pairs","text":"Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode newHead = new ListNode(0); newHead.next = head; ListNode pre = newHead; while(pre.next!=null &amp;&amp; pre.next.next!=null){ ListNode first = pre.next; pre.next = first.next; first.next = first.next.next; pre.next.next = first; pre = first; } return newHead.next; }}","link":"/2019/07/10/leetcode 24. Swap Nodes in Pairs/"},{"title":"leetcode 703. Kth Largest Element in a Stream","text":"Example: 12345678int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 1234567891011121314151617181920212223242526272829303132333435class KthLargest { private int k; private PriorityQueue&lt;Integer&gt; queue; public KthLargest(int k, int[] nums) { this.k = k; queue = new PriorityQueue(); for (int num : nums) { add(num); } } public int add(int val) { if (queue.size() &lt; k) { queue.offer(val); return queue.peek(); } int target = queue.peek(); if (val &lt; target) { return target; } queue.poll(); queue.offer(val); return queue.peek(); }}/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */","link":"/2019/07/10/leetcode 703. Kth Largest Element in a Stream/"},{"title":"leetcode 1. Two Sum","text":"problemGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. approach 1算法12345678910111213141516171819202122232425262728/* * @lc app=leetcode id=1 lang=java * * [1] Two Sum */class Solution { public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if (nums == null || nums.length &lt;= 1) { return res; } Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { Integer pst = m.get(nums[i]); if (pst == null) { m.put(target - nums[i], i); } else { res[0] = pst; res[1] = i; break; } } return res; }} 复杂度 time:O(n) space:O(n) approach 2算法双循环 复杂度 time:O(n^2) space:O(1)","link":"/2019/07/11/leetcode-1-Two-Sum/"},{"title":"leetcode 15. 3Sum","text":"problemGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] approach 1算法暴力解法，3 层循环 复杂度 time:O(n^3) space:O(1) approach 2算法2 层+set 复杂度 time:O(n^2) space:O(n) approach 3算法1234567891011121314151617181920212223242526272829303132class Solution { public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { if (nums == null || nums.length &lt; 3) { return Collections.EMPTY_LIST; } Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) { if (i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) { continue; } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int j = i + 1; j &lt; nums.length; j++) { if (set.contains(nums[j])) { res.add(Arrays.asList(nums[i], (-nums[i] - nums[j]), nums[j])); set.remove(nums[j]); } else { set.add(-nums[i] - nums[j]); } } } return new ArrayList&lt;&gt;(res); }} 复杂度 time:O() space:O() summery","link":"/2019/07/11/leetcode-15-3Sum/"},{"title":"leetcode 242. Valid Anagram","text":"problemGiven two strings s and t , write a function to determine if t is an anagram of s. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? approach 1算法sort 1234567891011121314151617181920/* * @lc app=leetcode id=242 lang=java * * [242] Valid Anagram */class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } char[] s1 = s.toCharArray(); char[] t1 = t.toCharArray(); Arrays.sort(s1); Arrays.sort(t1); return Arrays.equals(s1, t1); }} 复杂度 time:O(nlogn) 快排 space:O() approach 2算法map 123456789101112131415161718192021222324252627/* * @lc app=leetcode id=242 lang=java * * [242] Valid Anagram */class Solution { public boolean isAnagram(String s, String t) { Map&lt;Character, Integer&gt; m1 = countCharacter(s); Map&lt;Character, Integer&gt; m2 = countCharacter(t); return m1.equals(m2); } private Map&lt;Character, Integer&gt; countCharacter(String str) { Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;(); for (Character c : str.toCharArray()) { Integer cnt = m.get(c); if (cnt == null) { m.put(c, 1); } else { m.put(c, ++cnt); } } return m; }} 复杂度 time:O(n) space:O() approach 3算法相当自建hash 12345678910111213141516public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } int[] counter = new int[26]; for (int i = 0; i &lt; s.length(); i++) { counter[s.charAt(i) - &apos;a&apos;]++; counter[t.charAt(i) - &apos;a&apos;]--; } for (int count : counter) { if (count != 0) { return false; } } return true;} 复杂度 time:O() space:O()","link":"/2019/07/11/leetcode-242-Valid-Anagram/"},{"title":"linux","text":"linux的体系结构 如何查找特定的文件:find find ~ -name “target.java” 精确查找文件 find ~ -name “target*” 模糊查找文件 find ~ -iname “target*” 不区分大小写去查找文件 检索文件内容 grep 查找文件里符合条件的字符串 管道操作符 |,将前一个指令的输出作为后一个指令的输入 常用命令 如何对文件内容做统计 awk 1234awk &apos;{print $1,$3}&apos; netstat.txtawk &apos;($1==&quot;tcp&quot; &amp;&amp; $2==1) || NR==1 {print $0}&apos; netstat.textawk -F &quot;,&quot; &apos;{prrint $2}&apos; netstat.txtgrep &apos;parital\\[true\\]&apos; bac.log| grep -o &apos;engin\\[[0-1a-z]*\\]&apos;| awk &apos;{enginarr[$1]++}END{for(i in anginarr)print i &quot;\\t&quot; enginarr[i]}&apos; 批量替换文件内容 sed 12345sed &apos;s/^Str/String/&apos; replace.javased -i &apos;s/\\./\\;/&apos; replace.java 直接在目标文本修改sed -i &apos;s/jack/me/g&apos; repalce.java 全部替换sed -i &apos;/^ *$/d/&apos; replace.java 删除空行sed -i &apos;/Integer/d&apos; repalce.java","link":"/2019/07/23/linux/"},{"title":"redis","text":"为什么redis能这么快100000+qps 完全基于内存,绝大部分请求是纯粹的内存操作 数据结构简单,键值对,查找的时间复杂度是O(1) 采用单线程,单线程也能处理高并发请求,想多核也可启动多实例(单线程只是处理网络请求的时候是单线程) 使用多路I/O复用模型,非阻塞IO 多路IO复用模型 FD:File Descriptor,文件描述符一个打开的文件通过唯一的描述符进行引用,该描述符是打开文件的元数据到文件本身的映射 传统的阻塞I/O模型当对某个文件进行读写时,如果当前FD不可读或者不可写,redis就不会对其他操作进行响应,导致服务不可用 select系统调用:监听文件是否可读写 redis采用的IO多路复用函数:epoll/kqueue/evport/select 因地制宜 优先选择时间复杂度为O(1)的函数 select时间复杂度为O(n)作为保底 基于react设计模式监听I/O事件 redis使用的数据类型 从海量Key查询出某一固定前缀的Key 问清数据规模 使用keys对线上业务的影响keys指令一次性返回所有匹配的key,key的数量过大会使服务卡顿 使用scan指令:无阻塞scan 0 k1* count 10(返回 游标1232 和匹配的元素)scan 1232 k1* count 10 java可以将结果放入set去重 如何通过redis实现分布式锁分布式锁需要解决的问题 互斥性:只能由一个客户端获取到锁 安全性:只能由获取锁的客户端删除锁 死锁:获取到锁的客户端宕机,需要由机制防止 容错:部分节点宕机,仍然可以获取锁 setnx key val 解决setnx长期有效 如果大量的key同时过期需要注意什么集中过期,由于删除大量key需要时间,会出现卡顿现象 解决:设置key的过期时间时,给每个key加上随机值 如何使用redis做异步队列 使用List作为队列,rpush生产消息,lpop消费消息. 缺点:没有等待队列里有值才去消费,可以在程序中引入sleep机制去调用lpop重试 blpop key timeout:阻塞直到队列有消息或者超时 缺点:只能提供给一个消费者 pub/sub:主题订阅者模式-一对多 缺点:消息的发布无状态,无法保证被接收到 redis如何做持久化RDB(快照)持久化:保存某个时间节点的全量数据快照 sava:阻塞服务进程,直到RDB创建完成 bgsave:fork出一个子进程来创建RDB文件,不阻塞服务器进程 自动化触发RDB持久化 bgsave原理 RDB持久化的缺点 全量同步,数据量大会由于IO而严重影响性能 可能会因为redis挂掉而丢失从当前至最近一次快照期间的数据 AOF(Append-Only-File)持久化:保存写状态 记录下除了查询以外的所有变更数据库状态的命令 以append的形式追加到AOF文件中 RDB和AOF共存的情况下的恢复流程 RDB和AOF的优缺点 RDB-AOF混合持久化bgsave做镜像全量持久化,aof做增量持久化 使用Pipeline的好处 Redis的主从同步主从同步原理 全同步 增量同步 主从同步Master宕机后的主从切换问题 留言协议Gossip在杂乱无章中寻求一致 Redis的集群原理如何从海量数据中快速找到所需 分片:按照某种规则去划分数据,分散存储在多个节点上 常规的哈希划分无法实现节点的动态增减 一致性哈希算法:对2^32取模,将哈希值空间组织成虚拟的圆环.一致性哈希算法对于节点的增减都只需重新定位环中的一小部分数据. 一致性哈希算法缺点:节点少的时候会发生数据倾斜.解决:引入虚拟节点","link":"/2019/07/21/redis/"},{"title":"springcloud","text":"单体应用存在的问题 随着业务的发展，开发变得越来越复杂。 修改、新增某个功能，需要对整个系统进行测试、重新部署。 一个模块出现问题，很可能导致整个系统崩溃。 多个开发团队同时对数据进行管理，容易产生安全漏洞。 各个模块使用同一种技术进行开发，各个模块很难根据实际情况选择更合适的技术框架，局限性很大。 模块内容过于复杂，如果员工离职，可能需要很长时间才能完成工作交接。 分布式、集群 集群：一台服务器无法负荷高并发的数据访问量，那么就设置十台服务器一起分担压力，十台不行就设置一百台（物理层面）。很多人干同一件事情，来分摊压力。 分布式：将一个复杂问题拆分成若干个简单的小问题，将一个大型的项目架构拆分成若干个微服务来协同完成。（软件设计层面）。将一个庞大的工作拆分成若干个小步骤，分别由不同的人完成这些小步骤，最终将所有的结果进行整合实现大的需求。 服务治理的核心又三部分组成：服务提供者、服务消费者、注册中心。 在分布式系统架构中，每个微服务在启动时，将自己的信息存储在注册中心，叫做服务注册。 服务消费者从注册中心获取服务提供者的网络信息，通过该信息调用服务，叫做服务发现。 Spring Cloud 的服务治理使用 Eureka 来实现，Eureka 是 Netflix 开源的基于 REST 的服务治理解决方案，Spring Cloud 集成了 Eureka，提供服务注册和服务发现的功能，可以和基于 Spring Boot 搭建的微服务应用轻松完成整合，开箱即用，Spring Cloud Eureka。 Spring Cloud Eureka Eureka Server，注册中心 Eureka Client，所有要进行注册的微服务通过 Eureka Client 连接到 Eureka Server，完成注册。 Eureka Server代码实现 创建父工程，pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 解决 JDK 9 以上没有 JAXB API 的问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在父工程下创建 Module，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml，添加 Eureka Server 相关配置。 12345678server: port: 8761eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:8761/eureka/ 属性说明 server.port：当前 Eureka Server 服务端口。 eureka.client.register-with-eureka：是否将当前的 Eureka Server 服务作为客户端进行注册。 eureka.client.fetch-fegistry：是否获取其他 Eureka Server 服务的数据。 eureka.client.service-url.defaultZone：注册中心的访问地址。 创建启动类 12345678910111213package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class,args); }} 注解说明： @SpringBootApplication：声明该类是 Spring Boot 服务的入口。 @EnableEurekaServer：声明该类是一个 Eureka Server 微服务，提供服务注册和服务发现功能，即注册中心。 Eureka Client 代码实现 创建 Module ，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml，添加 Eureka Client 相关配置 1234567891011server: port: 8010spring: application: name: providereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 属性说明： spring.application.name：当前服务注册在 Eureka Server 上的名称。 eureka.client.service-url.defaultZone：注册中心的访问地址。 eureka.instance.prefer-ip-address：是否将当前服务的 IP 注册到 Eureka Server。 创建启动类 1234567891011package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ProviderApplication { public static void main(String[] args) { SpringApplication.run(ProviderApplication.class,args); }} 实体类 1234567891011121314package com.southwind.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Student { private long id; private String name; private int age;} Repository 123456789101112package com.southwind.repository;import com.southwind.entity.Student;import java.util.Collection;public interface StudentRepository { public Collection&lt;Student&gt; findAll(); public Student findById(long id); public void saveOrUpdate(Student student); public void deleteById(long id);} RepositoryImpl 123456789101112131415161718192021222324252627282930313233343536373839404142package com.southwind.repository.impl;import com.southwind.entity.Student;import com.southwind.repository.StudentRepository;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.Map;@Repositorypublic class StudentRepositoryImpl implements StudentRepository { private static Map&lt;Long,Student&gt; studentMap; static { studentMap = new HashMap&lt;&gt;(); studentMap.put(1L,new Student(1L,\"张三\",22)); studentMap.put(2L,new Student(2L,\"李四\",23)); studentMap.put(3L,new Student(3L,\"王五\",24)); } @Override public Collection&lt;Student&gt; findAll() { return studentMap.values(); } @Override public Student findById(long id) { return studentMap.get(id); } @Override public void saveOrUpdate(Student student) { studentMap.put(student.getId(),student); } @Override public void deleteById(long id) { studentMap.remove(id); }} Handler 12345678910111213141516171819202122232425262728293031323334353637383940package com.southwind.controller;import com.southwind.entity.Student;import com.southwind.repository.StudentRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.Collection;@RestController@RequestMapping(\"/student\")public class StudentHandler { @Autowired private StudentRepository studentRepository; @GetMapping(\"/findAll\") public Collection&lt;Student&gt; findAll(){ return studentRepository.findAll(); } @GetMapping(\"/findById/{id}\") public Student findById(@PathVariable(\"id\") long id){ return studentRepository.findById(id); } @PostMapping(\"/save\") public void save(@RequestBody Student student){ studentRepository.saveOrUpdate(student); } @PutMapping(\"/update\") public void update(@RequestBody Student student){ studentRepository.saveOrUpdate(student); } @DeleteMapping(\"/deleteById/{id}\") public void deleteById(@PathVariable(\"id\") long id){ studentRepository.deleteById(id); }} RestTemplate 的使用 什么是 RestTemplate？ RestTemplate 是 Spring 框架提供的基于 REST 的服务组件，底层是对 HTTP 请求及响应进行了封装，提供了很多访问 RETS 服务的方法，可以简化代码开发。 如何使用 RestTemplate？ 1、创建 Maven 工程，pom.xml。 2、创建实体类 1234567891011121314package com.southwind.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Student { private long id; private String name; private int age;} 3、Handler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.southwind.controller;import com.southwind.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestTemplate;import java.util.Collection;@RestController@RequestMapping(\"/rest\")public class RestHandler { @Autowired private RestTemplate restTemplate; @GetMapping(\"/findAll\") public Collection&lt;Student&gt; findAll(){ return restTemplate.getForEntity(\"http://localhost:8010/student/findAll\",Collection.class).getBody(); } @GetMapping(\"/findAll2\") public Collection&lt;Student&gt; findAll2(){ return restTemplate.getForObject(\"http://localhost:8010/student/findAll\",Collection.class); } @GetMapping(\"/findById/{id}\") public Student findById(@PathVariable(\"id\") long id){ return restTemplate.getForEntity(\"http://localhost:8010/student/findById/{id}\",Student.class,id).getBody(); } @GetMapping(\"/findById2/{id}\") public Student findById2(@PathVariable(\"id\") long id){ return restTemplate.getForObject(\"http://localhost:8010/student/findById/{id}\",Student.class,id); } @PostMapping(\"/save\") public void save(@RequestBody Student student){ restTemplate.postForEntity(\"http://localhost:8010/student/save\",student,null).getBody(); } @PostMapping(\"/save2\") public void save2(@RequestBody Student student){ restTemplate.postForObject(\"http://localhost:8010/student/save\",student,null); } @PutMapping(\"/update\") public void update(@RequestBody Student student){ restTemplate.put(\"http://localhost:8010/student/update\",student); } @DeleteMapping(\"/deleteById/{id}\") public void deleteById(@PathVariable(\"id\") long id){ restTemplate.delete(\"http://localhost:8010/student/deleteById/{id}\",id); }} 4、启动类 123456789101112131415161718package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplicationpublic class RestTemplateApplication { public static void main(String[] args) { SpringApplication.run(RestTemplateApplication.class,args); } @Bean public RestTemplate restTemplate(){ return new RestTemplate(); }} 服务消费者 consumer 创建 Maven 工程，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 1234567891011server: port: 8020spring: application: name: consumereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 创建启动类 123456789101112131415161718package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplicationpublic class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class,args); } @Bean public RestTemplate restTemplate(){ return new RestTemplate(); }} Handler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.southwind.controller;import com.southwind.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestTemplate;import java.util.Collection;@RestController@RequestMapping(\"/consumer\")public class ConsumerHandler { @Autowired private RestTemplate restTemplate; @GetMapping(\"/findAll\") public Collection&lt;Student&gt; findAll(){ return restTemplate.getForEntity(\"http://localhost:8010/student/findAll\",Collection.class).getBody(); } @GetMapping(\"/findAll2\") public Collection&lt;Student&gt; findAll2(){ return restTemplate.getForObject(\"http://localhost:8010/student/findAll\",Collection.class); } @GetMapping(\"/findById/{id}\") public Student findById(@PathVariable(\"id\") long id){ return restTemplate.getForEntity(\"http://localhost:8010/student/findById/{id}\",Student.class,id).getBody(); } @GetMapping(\"/findById2/{id}\") public Student findById2(@PathVariable(\"id\") long id){ return restTemplate.getForObject(\"http://localhost:8010/student/findById/{id}\",Student.class,id); } @PostMapping(\"/save\") public void save(@RequestBody Student student){ restTemplate.postForEntity(\"http://localhost:8010/student/save\",student,null).getBody(); } @PostMapping(\"/save2\") public void save2(@RequestBody Student student){ restTemplate.postForObject(\"http://localhost:8010/student/save\",student,null); } @PutMapping(\"/update\") public void update(@RequestBody Student student){ restTemplate.put(\"http://localhost:8010/student/update\",student); } @DeleteMapping(\"/deleteById/{id}\") public void deleteById(@PathVariable(\"id\") long id){ restTemplate.delete(\"http://localhost:8010/student/deleteById/{id}\",id); }} 服务网关Spring Cloud 集成了 Zuul 组件，实现服务网关。 什么是 Zuul？ Zuul 是 Netflix 提供的一个开源的 API 网关服务器，是客户端和网站后端所有请求的中间层，对外开放一个 API，将所有请求导入统一的入口，屏蔽了服务端的具体实现逻辑，Zuul 可以实现反向代理的功能，在网关内部实现动态路由、身份认证、IP 过滤、数据监控等。 创建 Maven 工程，pom.xml 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 123456789101112server: port: 8030spring: application: name: gatewayeureka: client: service-url: defaultZone: http://localhost:8761/eureka/zuul: routes: provider: /p/** 属性说明： zuul.routes.provider：给服务提供者 provider 设置映射 创建启动类 12345678910111213package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@EnableZuulProxy@EnableAutoConfigurationpublic class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class,args); }} 注解说明： @EnableZuulProxy：包含了 @EnableZuulServer，设置该类是网关的启动类。 @EnableAutoConfiguration：可以帮助 Spring Boot 应用将所有符合条件的 @Configuration 配置加载到当前 Spring Boot 创建并使用的 IoC 容器中。 Zuul 自带了负载均衡功能，修改 provider 的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.southwind.controller;import com.southwind.entity.Student;import com.southwind.repository.StudentRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import java.util.Collection;@RestController@RequestMapping(\"/student\")public class StudentHandler { @Autowired private StudentRepository studentRepository; @Value(\"${server.port}\") private String port; @GetMapping(\"/findAll\") public Collection&lt;Student&gt; findAll(){ return studentRepository.findAll(); } @GetMapping(\"/findById/{id}\") public Student findById(@PathVariable(\"id\") long id){ return studentRepository.findById(id); } @PostMapping(\"/save\") public void save(@RequestBody Student student){ studentRepository.saveOrUpdate(student); } @PutMapping(\"/update\") public void update(@RequestBody Student student){ studentRepository.saveOrUpdate(student); } @DeleteMapping(\"/deleteById/{id}\") public void deleteById(@PathVariable(\"id\") long id){ studentRepository.deleteById(id); } @GetMapping(\"/index\") public String index(){ return \"当前端口：\"+this.port; }} Ribbon 负载均衡 什么是 Ribbon？ Spring Cloud Ribbon 是一个负载均衡解决方案，Ribbon 是 Netflix 发布的负载均衡器，Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的，是一个用于对 HTTP 请求进行控制的负载均衡客户端。 在注册中心对 Ribbon 进行注册之后，Ribbon 就可以基于某种负载均衡算法，如轮询、随机、加权轮询、加权随机等自动帮助服务消费者调用接口，开发者也可以根据具体需求自定义 Ribbon 负载均衡算法。实际开发中，Spring Cloud Ribbon 需要结合 Spring Cloud Eureka 来使用，Eureka Server 提供所有可以调用的服务提供者列表，Ribbon 基于特定的负载均衡算法从这些服务提供者中选择要调用的具体实例。 创建 Module，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 1234567891011server: port: 8040spring: application: name: ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 创建启动类 1234567891011121314151617181920package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplicationpublic class RibbonApplication { public static void main(String[] args) { SpringApplication.run(RibbonApplication.class,args); } @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); }} @LoadBalanced：声明一个基于 Ribbon 的负载均衡。 Handler 123456789101112131415161718192021222324252627package com.southwind.controller;import com.southwind.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.Collection;@RestController@RequestMapping(\"/ribbon\")public class RibbonHandler { @Autowired private RestTemplate restTemplate; @GetMapping(\"/findAll\") public Collection&lt;Student&gt; findAll(){ return restTemplate.getForObject(\"http://provider/student/findAll\",Collection.class); } @GetMapping(\"/index\") public String index(){ return restTemplate.getForObject(\"http://provider/student/index\",String.class); }} Feign 什么是 Feign？ 与 Ribbon 一样，Feign 也是由 Netflix 提供的，Feign 是一个声明式、模版化的 Web Service 客户端，它简化了开发者编写 Web 服务客户端的操作，开发者可以通过简单的接口和注解来调用 HTTP API，Spring Cloud Feign，它整合了 Ribbon 和 Hystrix，具有可插拔、基于注解、负载均衡、服务熔断等一系列便捷功能。 相比较于 Ribbon + RestTemplate 的方式，Feign 大大简化了代码的开发，Feign 支持多种注解，包括 Feign 注解、JAX-RS 注解、Spring MVC 注解等，Spring Cloud 对 Feing 进行了优化，整合了 Ribbon 和 Eureka，从而让 Feign 的使用更加方便。 Ribbon 和 Feign 的区别 Ribbon 是一个通用的 HTTP 客户端工具，Feign 是基于 Ribbon 实现的。 Feign 的特点 1、Feign 是一个声明式的 Web Service 客户端。 2、支持 Feign 注解、Spring MVC 注解、JAX-RS 注解。 3、Feign 基于 Ribbon 实现，使用起来更加简单。 4、Feign 集成了 Hystrix，具备服务熔断的功能。 创建 Module，pom.xml 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 1234567891011server: port: 8050spring: application: name: feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 创建启动类 12345678910111213package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClientspublic class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class,args); }} 创建声明式接口 12345678910111213141516package com.southwind.feign;import com.southwind.entity.Student;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.Collection;@FeignClient(value = \"provider\")public interface FeignProviderClient { @GetMapping(\"/student/findAll\") public Collection&lt;Student&gt; findAll(); @GetMapping(\"/student/index\") public String index();} Handler 12345678910111213141516171819202122232425262728package com.southwind.controller;import com.southwind.entity.Student;import com.southwind.feign.FeignProviderClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Collection;@RestController@RequestMapping(\"/feign\")public class FeignHandler { @Autowired private FeignProviderClient feignProviderClient; @GetMapping(\"/findAll\") public Collection&lt;Student&gt; findAll(){ return feignProviderClient.findAll(); } @GetMapping(\"/index\") public String index(){ return feignProviderClient.index(); }} 服务熔断，application.yml 添加熔断机制。 1234567891011121314server: port: 8050spring: application: name: feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: truefeign: hystrix: enabled: true feign.hystrix.enabled：是否开启熔断器。 创建 FeignProviderClient 接口的实现类 FeignError，定义容错处理逻辑，通过 @Component 注解将 FeignError 实例注入 IoC 容器中。 1234567891011121314151617181920package com.southwind.feign.impl;import com.southwind.entity.Student;import com.southwind.feign.FeignProviderClient;import org.springframework.stereotype.Component;import java.util.Collection;@Componentpublic class FeignError implements FeignProviderClient { @Override public Collection&lt;Student&gt; findAll() { return null; } @Override public String index() { return \"服务器维护中......\"; }} 在 FeignProviderClient 定义处通过 @FeignClient 的 fallback 属性设置映射。 1234567891011121314151617package com.southwind.feign;import com.southwind.entity.Student;import com.southwind.feign.impl.FeignError;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.Collection;@FeignClient(value = \"provider\",fallback = FeignError.class)public interface FeignProviderClient { @GetMapping(\"/student/findAll\") public Collection&lt;Student&gt; findAll(); @GetMapping(\"/student/index\") public String index();} Hystrix 容错机制在不改变各个微服务调用关系的前提下，针对错误情况进行预先处理。 设计原则 1、服务隔离机制 2、服务降级机制 3、熔断机制 4、提供实时的监控和报警功能 5、提供实时的配置修改功能 Hystrix 数据监控需要结合 Spring Boot Actuator 来使用，Actuator 提供了对服务的健康健康、数据统计，可以通过 hystrix.stream 节点获取监控的请求数据，提供了可视化的监控界面。 创建 Maven，pom.xml 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 12345678910111213141516171819server: port: 8060spring: application: name: hystrixeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: truefeign: hystrix: enabled: truemanagement: endpoints: web: exposure: include: 'hystrix.stream' 创建启动类 1234567891011121314151617package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients@EnableCircuitBreaker@EnableHystrixDashboardpublic class HystrixApplication { public static void main(String[] args) { SpringApplication.run(HystrixApplication.class,args); }} 注解说明： @EnableCircuitBreaker：声明启用数据监控 @EnableHystrixDashboard：声明启用可视化数据监控 Handler 123456789101112131415161718192021222324252627package com.southwind.controller;import com.southwind.entity.Student;import com.southwind.feign.FeignProviderClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Collection;@RestController@RequestMapping(\"/hystrix\")public class HystrixHandler { @Autowired private FeignProviderClient feignProviderClient; @GetMapping(\"/findAll\") public Collection&lt;Student&gt; findAll(){ return feignProviderClient.findAll(); } @GetMapping(\"/index\") public String index(){ return feignProviderClient.index(); }} 启动成功之后，访问 http://localhost:8060/actuator/hystrix.stream 可以监控到请求数据， 访问 http://localhost:8060/hystrix，可以看到可视化的监控界面，输入要监控的地址节点即可看到该节点的可视化数据监控。 Spring Cloud 配置中心Spring Cloud Config，通过服务端可以为多个客户端提供配置服务。Spring Cloud Config 可以将配置文件存储在本地，也可以将配置文件存储在远程 Git 仓库，创建 Config Server，通过它管理所有的配置文件。 本地文件系统 创建 Maven 工程，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 application.yml 123456789101112server: port: 8762spring: application: name: nativeconfigserver profiles: active: native cloud: config: server: native: search-locations: classpath:/shared 注解说明 profiles.active：配置文件的获取方式 cloud.config.server.native.search-locations：本地配置文件存放的路径 resources 路径下创建 shared 文件夹，并在此路径下创建 configclient-dev.yml。 123server: port: 8070foo: foo version 1 创建启动类 12345678910111213package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class NativeConfigServerApplication { public static void main(String[] args) { SpringApplication.run(NativeConfigServerApplication.class,args); }} 注解说明 @EnableConfigServer：声明配置中心。 创建客户端读取本地配置中心的配置文件 创建 Maven 工程，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 bootstrap.yml，配置读取本地配置中心的相关信息。 123456789spring: application: name: configclient profiles: active: dev cloud: config: uri: http://localhost:8762 fail-fast: true 注解说明 cloud.config.uri：本地 Config Server 的访问路径 cloud.config.fail-fase：设置客户端优先判断 Config Server 获取是否正常。 通过spring.application.name 结合spring.profiles.active拼接目标配置文件名，configclient-dev.yml，去 Config Server 中查找该文件。 创建启动类 1234567891011package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class NativeConfigClientApplication { public static void main(String[] args) { SpringApplication.run(NativeConfigClientApplication.class,args); }} Handler 12345678910111213141516171819202122package com.southwind.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"/native\")public class NativeConfigHandler { @Value(\"${server.port}\") private String port; @Value(\"${foo}\") private String foo; @GetMapping(\"/index\") public String index(){ return this.port+\"-\"+this.foo; }} Spring Cloud Config 远程配置 创建配置文件，上传至 GitHub 123456789server: port: 8070eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/spring: application: name: configclient 创建 Config Server，新建 Maven 工程，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 123456789101112131415161718server: port: 8888spring: application: name: configserver cloud: config: server: git: uri: https://github.com/southwind9801/aispringcloud.git searchPaths: config username: root password: root label: mastereureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 创建启动类 12345678910111213package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class,args); }} 创建 Config Client 创建 Maven 工程，pom.xml 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建 bootstrap.yml 123456789101112spring: cloud: config: name: configclient label: master discovery: enabled: true service-id: configservereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 注解说明 spring.cloud.config.name：当前服务注册在 Eureka Server 上的名称，与远程仓库的配置文件名对应。 spring.cloud.config.label：Git Repository 的分支。 spring.cloud.config.discovery.enabled：是否开启 Config 服务发现支持。 spring.cloud.config.discovery.service-id：配置中心在 Eureka Server 上注册的名称。 创建启动类 1234567891011package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ConfigClientApplication { public static void main(String[] args) { SpringApplication.run(ConfigClientApplication.class,args); }} Handler 12345678910111213141516171819package com.southwind.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"/hello\")public class HelloHandler { @Value(\"${server.port}\") private String port; @GetMapping(\"/index\") public String index(){ return this.port; }} 服务跟踪Spring Cloud Zipkin Zipkin 是一个可以采集并且跟踪分布式系统中请求数据的组件，让开发者可以更加直观的监控到请求在各个微服务所耗费的时间等，Zipkin：Zipkin Server、Zipkin Client。 ####创建 Zipkin Server 创建 Maven 工程，pom.xml 12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 12server: port: 9090 创建启动类 12345678910111213package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import zipkin.server.internal.EnableZipkinServer;@SpringBootApplication@EnableZipkinServerpublic class ZipkinApplication { public static void main(String[] args) { SpringApplication.run(ZipkinApplication.class,args); }} 注解说明 @EnableZipkinServer：声明启动 Zipkin Server 创建 Zipkin Client 创建 Maven 工程，pom.xml 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 application.yml 1234567891011121314151617server: port: 8090spring: application: name: zipkinclient sleuth: web: client: enabled: true sampler: probability: 1.0 zipkin: base-url: http://localhost:9090/eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 属性说明 spring.sleuth.web.client.enabled：设置开启请求跟踪 spring.sleuth.sampler.probability：设置采样比例，默认是 1.0 srping.zipkin.base-url：Zipkin Server 地址 创建启动类 1234567891011package com.southwind;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ZipkinClientApplication { public static void main(String[] args) { SpringApplication.run(ZipkinClientApplication.class,args); }} Handler 12345678910111213141516171819package com.southwind.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"/zipkin\")public class ZipkinHandler { @Value(\"${server.port}\") private String port; @GetMapping(\"/index\") public String index(){ return this.port; }}","link":"/2019/10/23/springcloud/"},{"title":"哈希表","text":"HashTable &amp; Hash Function &amp; Collisions HashMap,HashSet,TreeMap,TreeSethashtable vs binary-serch-tree 但是二叉搜索树相对有序","link":"/2019/07/11/哈希表/"},{"title":"32.N皇后问题：leetcode51","text":"problemGiven an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. 1234567891011121314Example:Input: 4Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] approach112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); helper(res, new int[n], 0); return res; } private void helper(List&lt;List&lt;String&gt;&gt; res, int[] queens, int pos) { if (pos == queens.length) { addResult(res, queens); return; } for (int i = 0; i &lt; queens.length; i++) { queens[pos] = i; if (isValid(pos, queens)) { helper(res, queens, pos + 1); } } } private boolean isValid(int pos, int[] queens) { for (int i = 0; i &lt; pos; i++) { if (queens[i] == queens[pos]) { return false; } else if (Math.abs(queens[pos] - queens[i]) == Math.abs(i - pos)) { return false; } } return true; } private void addResult(List&lt;List&lt;String&gt;&gt; res, int[] queens) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; queens.length; i++) { StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; queens.length; j++) { if (j == queens[i]) { sb.append(\"Q\"); } else { sb.append(\".\"); } } list.add(sb.toString()); } res.add(list); }} time:O(n^2) space:O(n) approach212 time:O() space:O() approach312 time:O() space:O() summery","link":"/2019/09/18/32-N皇后问题：leetcode51/"},{"title":"19.二叉搜索树_最近公共祖先:leetcode235","text":"problemGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6. Example 2: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the BST. 初步分析: 1.分别得到两个节点的路径,再比较路径 approach 1:递归12345678910111213141516171819202122232425/* * @lc app=leetcode id=235 lang=java * * [235] Lowest Common Ancestor of a Binary Search Tree *//** * Definition for a binary tree node. public class TreeNode { int val; TreeNode * left; TreeNode right; TreeNode(int x) { val = x; } } */class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || p == null || q == null) { return null; } if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { return lowestCommonAncestor(root.left, p, q); } if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { return lowestCommonAncestor(root.right, p, q); } return root; }} 如果p和q都大于root，去左子树找；如果p和q都小于root，去右子树找；否则，p和q进行分叉，root就是要找的节点 非递归版本： 1234567891011121314class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { while (root != null) { if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { root = root.left; } else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { root = root.right; } else { break; } } return root; }} 复杂度 time:O(n) space:O(n)","link":"/2019/07/19/19-二叉搜索树-最近公共祖先-leetcode235/"},{"title":"数组和链表","text":"数组数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。 #链表 从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。 对比 数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。 数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。","link":"/2019/07/09/数组和链表/"},{"title":"网络","text":"网络基础知识OSI开发式互联参考模型 第一层【物理层】传输比特流。物理设备的标准，数模转换，网卡 第二次【数据链路层】物理寻址，同时将原始比特流转变为逻辑传输线路。 定义如何格式数据进行传输，错误检查和纠正。将比特数据组成帧，交换机工作在这一层，将帧解码，根据帧中的信息，把数据发送到接收方。 第三层【网络层】控制子网的运行，如逻辑编址、分组传输、路由选择。通讯时经过多个节点，如何找到目标节点，最佳路径？将网络地址翻译成物理地址，将数据从发送方路由到接收方，路由器属于网络层，这层数据称为数据包，需要关注的协议Ip协议 第四层【传输层】接受上一层数据，在必要时把数据进行分割，并将这些数据交给网络层，且保证这些数据有效到达对端。需要关注TCP，UDP协议 第五层【会话层】建立和管理应用程序之间的通信。自动收发包，寻址 第六层【表示层】信息的语法语义以及他们之间的关联。解决不同系统通信的语法问题 第七层【应用层】http协议 OSI的实现：TCP/IP四层架构模型 TCP的三次握手why:ip协议是无连接的通信协议，无法确认包是否按顺序发送，或者包是否被破坏，所以需要由下一层进行控制 报文头：源端口+目的端口+sequence number+acknowledge number+TCPflag 握手是为了建立连接，握手的流程图如下： 为什么需要三次握手才能建立起连接为了初始化双方的sequence number，作为以后的通讯序号，保证接收到数据乱序 首次握手的隐患–SYN超时服务器收到客户端的SYN，回复SYN-ACK时客户端掉线，服务端没有收到ACK确认，就会不断重试直到超时，可能遭到SYN Flood攻击。 防护措施：SYN队列满后，通过SYN Cookie，依然可以建立连接 建立连接后，客户端故障怎么办保活机制：向对方发送探测报文，如果未收到响应则继续发送，达到次数则中断连接 TCP的四次挥手 为什么会有2msl的time_wait的状态保证有足够时间让对方收到ＡＣＫ包，避免新旧连接混淆 为什么需要４次挥手双方都要接收到ＦＩＮ报文和ＡＣＫ报文 服务器出现大量CLOSE_WAIT的原因对方关闭socket连接，我方忙于读或写，没有及时关闭连接 检查代码资源释放，检查线程配置 1netstat -n |awk &apos;/^tcp/{++S[$NF]}END{for(a in s) print a,s[a]}&apos; UDP报文结构：源端口+目的端口+数据包长度+checksum+数据 TCP和UDP的区别 面向连接 vs 无连接（适合消息多播发布） 可靠性（TCP握手，UDP可能丢失） 有序性（TCP有序，UDP无序） 速度（TCP创建连接，较慢） 量级（数据头TCP20字节UDP8字节） TCP的滑动窗口 TCP的最基础的可靠性来源确认重传机制发送窗口左边界的数据连续被确认收到，据窗口才可以移动。滑动窗口的大小根据处理能力动态变化 Http协议 1.0-&gt;1.1 keep-alive 在浏览器地址栏键入Url，按下回车后经历的流程 DNS解析（浏览器依据url逐层查询dns缓存解析url对应的ip（浏览器缓存，系统缓存，路由器缓存。。）） TCP连接 http请求 服务器处理并返回http报文 浏览器解析渲染页面 释放连接 常见http状态码1XX 指示信息-请求已接受，继续处理2XX 成功-请求已成功接收，理解，接收3XX 重定向-要完成请求必须进一步操作4XX 客户端错误-请求有语法错误，或者无法实现 400 语法错误，不能理解 401 未授权 403 forbiden 404 notfound5XX 服务端错误 500 未知错误 503 当前无法处理，连接池满了 Get请求和Post请求的区别 报文上看：get请求将请求信息放在url中，post放在报文体中，get长度限制 数据库看：get符合幂等性和安全性，post不符合（post会提交数据，post每次请求会添加新资源） get可以被缓存，被储存，post不行 cookie和session的区别解决http请求的无状态 Cookie是客户端的解决方式 session 区别 http和https的区别 socket","link":"/2019/07/19/网络/"},{"title":"数据库","text":"数据库架构如何设计一个关系型数据库首先将其划分为存储部分和对存储进行逻辑管理的程序实例，存储部分类似一个文件系统，程序实例将包含数据逻辑关系转为物理存储关系的存储管理模块，优化存储效率的缓存模块，将sql语句进行解析的sql解析模块，记录操作的日志管理模块，进行多用户管理的权限划分模块，容灾模块，优化数据查询的索引模块，使数据库支持并发的锁模块。 索引为什么使用索引当查询大量数据，如果进行全表扫描，查询非常慢，所以需要更高效的机制来避免全表扫描。 什么样的信息能成为索引主键，唯一键，普通键等能让数据具备区分性 索引的数据结构主流是B+树，还有hash结构和BitMap，其中Mysql不支持BitMap，基于innodb和mysm引擎的mysql不显示支持hash 二叉查找树O(logn) 缺点：插入数据有可能变为线性二叉树-》树旋转 检索深度每增加1，就会发生一次io，检索性能降低。-》要使树变得矮一些，每个节点数据存储多一些， B树O(logn) 说明：前四条规则用来限制孩子数，最后一条规则限制节点关键字数量及大小。通过合并，分裂，上移下移来使树不变成线性 B+树O(logn)-主流 B+树只存索引信息，内部节点比B树更小，储存时，盘块所能容纳的关键字数量更多，一次性读入内存的关键字更多，减少io次数 Hash BitMap（位图索引） 密集索引和稀疏索引 innodb有且只有一个聚集索引，数据文件和索引绑在一起，必须要有主键，通过主键索引效率很高，但是辅助索引需要查两次。 myisam是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的，因此myisam适合增删改。 如何定位并优化慢查询sql 根据慢日志 根据explain 123explain select count(id) from person_info ;key-account 不是主键id，原因是密集索引的叶子索引把其他列的数据也存放在叶子节点中，查询效率比稀疏索引低 修改sql或者尽量让sql走索引 联合索引最左原则的成因最左匹配原则： mysql会一直向右匹配直到遇到范围查询就停止匹配，比如a=3 and b=2 and c&gt;3 and d=5，如果建立(a,b,c,d)索引，d是用不到索引的，如果建立的是(a,b,d,c)索引则都可以用到，且a，b，d的顺序是可以任意调整的 =和in是可以乱序的 成因： mysql创建复合索引时，首先对第一个字段进行排序，在第一个字段的基础上，再对第二个字段进行排序，依次类推，所以自能最左匹配 索引建立的越多越好吗 数据量小的表不需要索引，建立增加额外开销 数据变更需要维护索引，更多的索引意味着更多的维护成本 更多的索引意味着需要更多的空间 锁MyISAM和InnoDB的锁的区别是什么 myisam： 读写、写读-myisam在进行查询的时候，会加一个表级别的读锁；在进行增删改的时候会加一个表级别的写锁。在读锁未被释放，加写锁时会被阻塞，直到读锁被释放为止。 读读-可以同时进行，读锁又叫共享锁。（上排他锁，for update） 写写-不能同时写，写锁又叫排他锁 innodb： 二段锁：加锁解锁两个步骤，先对同一个事务里的一批操作做加锁，commit的时候再进行解锁 12345set autocommit=0；// 支持事务，需要关闭事务自动提交先读后写session1：select * from person_info where id=1;session12: update person_info set title =&quot;test&quot; where id=1;//本来应该阻塞，竟然成功//实际innodb对select做了改进，并未上读锁 表级锁和索引无关，行级锁和索引有关，当不走索引，表会被锁住 锁的力度越细，代价越高。表级锁只要在表的头部上锁，行级锁需要扫描到某行后对其加锁，开销更大 MyISAM默认用的是表级锁，不支持行级锁 InnoDB默认用的是行级锁，也支持表级锁 MyISAM适合的场景 频繁执行全表count语句 对数据的增删改的频率不高，查询频繁 没有事务 InnoDB适合的场景 增删改查频繁 需要事务 数据库锁的分类 自动锁包括myasm表锁，select for update，lock in share mode;//显示锁 dml锁增删改，ddl锁alter 悲观锁：操作数据会发生并发冲突，在数据处理过程将数据锁定，依靠数据库提供的锁机制实现。缺点：增加开销，降低并行性 乐观锁：认为不会发生并发冲突，到数据提交更新时才检查是否冲突，通过版本号和时间戳实现 有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下： 12//修改商品库存update item set quantity=quantity - 1 where id = 1 and quantity - 1 &gt; 0 事务的四大特性 原子性:事务包含的全部操作要么全部执行要么全部不执行 一致性:事务要确保数据库的状态从一个一致的状态转为另一个一致的状态(转帐) 隔离性:多个事务并发执行时,一个事务的执行不应该影响其他事务 持久性:一个事务的提交,他对数据库的修改 应该永久地保存在数据库中 事务的隔离级别以及各级别下的并发访问问题1select @@tx_isolation 事务并发访问引起的问题以及如何避免 更新丢失-mysql所有事务隔离级别在数据库层面上均可避免 脏读（读未提交）-解决：将隔离级别设置为读已提交read-committed就可避免 1set session transaction isolation level read uncommitted;//读未提交 不可重复读-解决：将隔离级别设置为可重复读repeatable-read 12345session1 一直查询，余额为1300session2 update balance=300，未提交session1 查询，余额为1300session2提交session1查询变为1600 -幻读（事务a查询若干条数据，事务b插入或修改了事务a的结果集，导致事务a像出现幻觉一样）-解决：将事务隔离级别设置为serializable 123456789session a： select * from account lock in share mode;//查出3条数据(rr级别下:无法插入,等待session a 提交,mysql的innodb在rr级别下避免了幻读)sessionb: insert into account;(rc级别下：竟然更新了4条数据)sesion a: update account set balance =100; 出于性能考虑，事务级别越高，降低数据库的并发度越低。 oracle默认读已提交read-committed；mysql的默认为repeatable-read； innodb可重复读rr级别如何避免幻读表象:快照读(非阻塞读)–伪mvcc 内在:行锁+gap锁 当前读和快照读当前读,加了锁的增删改查,也就是读取最新数据 快照读用于提升并发性能,基于多版本并发控制及mvcc,mvcc是行级锁的变种,在很多情况下避免了加锁操作,开销更低. 读取的有可能是历史版本(rr级别下,快照读取决快照创建的时机),在serializable下无效 12345678910111213s1:select * from A where id =2;// balance=1000s2:update A set balance=600 where id=2;rc级别下:s1:select * from A where id=2;//balance=600;s1:select * from A where id=2 lock in share mode;//balance=600rc级别下当前读和快照读读到的数据版本是一样的rr级别下:s1:select * from A where id=2;//balance=1000;s1:select * from A where id=2 lock in share mode;//balance=600rr级别下快照读有可能读到数据的历史版本 rc,rr级别下的InnoDB的非阻塞读如何实现 修改过程:先加上排他锁,然后拷贝一份到undo log中 readview决定可见性 取出的trx_id小于当前活跃事务Id rc级别下,每次快照读都会创建一个新的快照 rr级别下,快照读读的是第一次创建的快照 next-key锁(行锁+gap锁)gap锁,防止同一事务的两次当前读出现幻读,在rr级别以上才有 Gap锁用在非唯一索引或者不走索引的当前读中 关键语法group by 满足:select的列要么是group by的条件要么是统计相关的函数 列函数对于group by字句定义的每个组各返回一个结果 12345678910#查询所有同学的学号,选课数,总成绩select student_id,count(course_id),sum(score)from scoregroup by student_id#查询所有同学的学号,姓名,选课数,总成绩select s.student_id,t.name,count(course_id),sum(score)from score s,student twhere s.student_id = t.student_idgroup by student_id having 123456789101112#查询平均成绩大于60分的同学的学号和平均成绩select student_id,avg(score)from scoregroup by student_idhaving avg(score)&gt;60#查询没有学全所有课的同学的学号,姓名select s.student_id,t.namefrom score s,student twhere s.student_id=t.student_idgroup by student_idhaving count(s.course_id)&lt;(select count(*) from course group by course_id) 统计相关:count,sum,max,min,avg#","link":"/2019/07/19/数据库/"},{"title":"堆栈和队列","text":"Stack-先入后出-报纸 Queue-先入先出-队伍 PriorityQueue-优先队列 正常入、按照优先级出 实现机制，堆（二叉堆，多项式堆，斐波那契堆），二叉搜索树s 二叉堆的性能最差，斐波拉契堆效率最好（删除效率为O(logn,其他为 O(1)) java，Python中的堆已经实现好了，运用的是斐波拉契堆或者平衡二叉树","link":"/2019/07/10/堆栈和队列/"},{"title":"leetcode 239. Sliding Window Maximum","text":"题目Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7]Explanation:Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 012 2 1 [3 -1 -3] 5 3 6 7 3 123 3 1 3 [-1 -3 5] 3 6 7 5 234 4 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 思路解法1：max heapa.维护一个大顶堆b.取Max-&gt;top 复杂度O(n*logk) 解法2:双端队列a.入队b.维护 复杂度O(n*1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayDeque;import java.util.Deque;/* * @lc app=leetcode id=239 lang=java * * [239] Sliding Window Maximum */class Solution { public static int[] maxSlidingWindow(int[] nums, int k) { if (nums.length &lt;= 0) { return nums; } Deque&lt;Integer&gt; window = new ArrayDeque&lt;&gt;();// 用于储存窗口的下标 int[] res = new int[nums.length - k + 1]; // 从左边开始前进 for (int i = 0; i &lt; nums.length; i++) { //1.窗口界限 2.窗口左边最大的剔除 // 1 if (!window.isEmpty() &amp;&amp; window.peek() &lt;= i - k) { window.pollFirst(); } // 2 // 比窗口左边的小，继续，比窗口的大，删除左边的 while (!window.isEmpty() &amp;&amp; nums[window.peekLast()] &lt; nums[i]) { window.pollLast(); } window.offer(i); System.out.println(window); if (i &gt;= k - 1) { res[i - k + 1] = nums[window.peek()]; } } return res; }}","link":"/2019/07/11/leetcode 239. Sliding Window Maximum/"},{"title":"算法复杂度","text":"时间复杂度 O(1) 123int i = 8;int j = 6;int sum = i + j; O(logn)、O(nlogn) 1234i=1;while (i &lt;= n) { i = i * 2;} O(m+n)、O(m*n) 代码的复杂度由两个数据的规模来决定，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m) * T2(n) = O(f(m) * f(n))。 空间复杂度1234567891011void print(int n) { int i = 0; int[] a = new int[n]; for (i; i &lt;n; ++i) { a[i] = i * i; } for (i = n-1; i &gt;= 0; --i) { print out a[i] }} 我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。常见的空间复杂度就是 O(1)、O(n)、O(n2 )。 总结","link":"/2019/07/09/算法复杂度/"},{"title":"springboot","text":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); }} 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController { @ResponseBody @RequestMapping(\"/hello\") public String hello(){ return \"Hello World!\"; }} 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); }} @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: {lastName: zhangsan,age: 18} 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: {k1: v1,k2: 12} lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person { /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"${person.last-name}\") private String lastName; //@Value(\"#{11*2}\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = {\"classpath:person.properties\"})@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person { /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"${person.last-name}\") private String lastName; //@Value(\"#{11*2}\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = {\"classpath:beans.xml\"})导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); }} ##4、配置文件占位符 1、随机数12${random.value}、${random.int}、${random.long}${random.int(10)}、${random.int[1024,65536]} 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三${random.uuid}person.age=${random.int}person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; } 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); }} 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() { //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");} 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%nSpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ----&gt; [%thread] ---&gt; %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); return; } Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); } } //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) { return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); } //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration { private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) { this.resourceProperties = resourceProperties; } @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() { SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; } @Bean public ResourceHttpRequestHandler faviconRequestHandler() { ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; } } ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"${hello}\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； 补充：配合 th:object=&quot;${session.user}： &lt;div th:object=&quot;${session.user}&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； @{/order/process(execId=${execId},execType=&apos;FAST&apos;)} Fragment Expressions: ~{...}：片段引用表达式 &lt;div th:insert=&quot;~{commons :: main}&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件} ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); }} 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) { // for (WebMvcConfigurer delegate : this.delegates) { // delegate.addViewControllers(registry); // } } }} ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); }} 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc { 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class })//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class })public class WebMvcAutoConfiguration { 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); } //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); } }; return adapter; }} 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration { /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) { //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); } if (this.encoding != null) { messageSource.setDefaultEncoding(this.encoding.name()); } messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; } 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@{/asserts/css/signin.css}\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@{/asserts/img/bootstrap-solid.svg}\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#{login.username}\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#{login.password}\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#{login.password}\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#{login.remember}]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() { if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; }默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { }} @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); }} 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null){ //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }else{ //已登陆，放行请求 return true; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }} 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); } }; return adapter; } 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~{footer :: copy}\"&gt;&lt;/div&gt;~{templatename::selector}：模板名::选择器~{templatename::fragmentname}:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~{}：行内写法可以加上：[[~{}]];[(~{})]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"${activeUri=='main.html'?'nav-link active':'nav-link'}\" href=\"#\" th:href=\"@{/main.html}\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=\"@{/emp}\" method=\"post\"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=\"_method\";值就是我们指定的请求方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"${emp!=null}\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"${emp!=null}\" th:value=\"${emp.id}\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${emp.lastName}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"${emp!=null}?${emp.email}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${emp!=null}?${emp.gender==1}\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${emp!=null}?${emp.gender==0}\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"${emp!=null}?${dept.id == emp.department.id}\" th:value=\"${dept.id}\" th:each=\"dept:${depts}\" th:text=\"${dept.departmentName}\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"${emp!=null}?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=\"emp:${emps}\"&gt; &lt;td th:text=\"${emp.id}\"&gt;&lt;/td&gt; &lt;td&gt;[[${emp.lastName}]]&lt;/td&gt; &lt;td th:text=\"${emp.email}\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.gender}==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.department.departmentName}\"&gt;&lt;/td&gt; &lt;td th:text=\"${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@{/emp/}+${emp.id}\"&gt;编辑&lt;/a&gt; &lt;button th:attr=\"del_uri=@{/emp/}+${emp.id}\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function(){ //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; });&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; } ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(\"${server.error.path:${error.path:/error}}\")public class BasicErrorController extends AbstractErrorController { @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); } @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); } ​ 3、ErrorPageCustomizer： 12@Value(\"${error.path:/error}\")private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); } ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null;} 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; }}//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; } 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; }} 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){ return new EmbeddedServletContainerCustomizer() { //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); } };} 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;} FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;} ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;} SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration;} 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration { @Configuration @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat { @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } } /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty { @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow { @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() { return new UndertowEmbeddedServletContainerFactory(); } } 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory { //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);} 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);} 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); } return bean;}private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) { //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) { customizer.customize(bean); }}private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() { if (this.customizers == null) { // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); } return this.customizers;}ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); }} 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) { //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) { this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); } builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) { application.getSources().add(getClass()); } Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) { application.getSources().add(ErrorPageFilterConfiguration.class); } //启动Spring应用 return run(application);} 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = \"spring.datasource.type\")static class Generic { @Bean public DataSource dataSource(DataSourceProperties properties) { //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); }} 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; }} 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper { @Select(\"select * from department where id=#{id}\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#{id}\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#{departmentName})\") public int insertDept(Department department); @Update(\"update department set departmentName=#{departmentName} where id=#{id}\") public int updateDept(Department department);} 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); } }; }} 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); }} 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {} 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) { //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();} 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try { //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); }} SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener { //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args){ } @Override public void starting() { System.out.println(\"SpringApplicationRunListener...starting...\"); } @Override public void environmentPrepared(ConfigurableEnvironment environment) { Object o = environment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); } @Override public void contextPrepared(ConfigurableApplicationContext context) { System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); } @Override public void contextLoaded(ConfigurableApplicationContext context) { System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); } @Override public void finished(ConfigurableApplicationContext context, Throwable exception) { System.out.println(\"SpringApplicationRunListener...finished...\"); }} 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\"ApplicationRunner...run....\"); }} CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args)); }} 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"atguigu.hello\")public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; }} 123456789101112131415161718package com.atguigu.starter;public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHellAtguigu(String name){ return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); }} 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; }} 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples","link":"/2019/10/11/springboot/"}],"tags":[{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"BST","slug":"BST","link":"/tags/BST/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"backtracking","slug":"backtracking","link":"/tags/backtracking/"},{"name":"binary-search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"priorityQueue","slug":"priorityQueue","link":"/tags/priorityQueue/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"two-pointers","slug":"two-pointers","link":"/tags/two-pointers/"},{"name":"notbest","slug":"notbest","link":"/tags/notbest/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"dequeue","slug":"dequeue","link":"/tags/dequeue/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"待补充","slug":"待补充","link":"/categories/待补充/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"总结","slug":"总结","link":"/categories/总结/"}]}